# 核心功能架构

## 简介

本文档详细介绍 ainote-server 项目中各个核心服务模块的架构设计，包括认证服务、笔记服务、日志服务、文件存储服务和台账服务等。通过理解这些服务的内部实现和交互关系，开发者可以更好地进行功能扩展和系统维护。

## 认证服务架构

### 整体架构

认证服务基于 JWT（JSON Web Token）实现无状态认证，包含用户注册、登录、Token 刷新等核心功能。

```mermaid
graph TB
    Client[客户端] --> AuthFilter[JWT认证过滤器]
    AuthFilter --> AuthService[认证服务]
    AuthService --> UserDetailsService[用户详情服务]
    AuthService --> JwtTokenProvider[JWT Token提供者]
    UserDetailsService --> UserRepository[用户仓储]
    JwtTokenProvider --> BCryptPasswordEncoder[密码编码器]
```

### 核心组件

#### AuthService

认证服务的核心实现类：

```kotlin
@Service
@Transactional
class AuthService(
    private val accountRepository: AccountRepository,
    private val passwordEncoder: BCryptPasswordEncoder,
    private val jwtTokenProvider: JwtTokenProvider
) {

    fun login(loginRequest: LoginRequest): LoginResponse {
        val user = accountRepository.findByUsername(loginRequest.username)
            ?: throw AuthenticationException("用户名或密码错误")

        if (!passwordEncoder.matches(loginRequest.password, user.password)) {
            throw AuthenticationException("用户名或密码错误")
        }

        val token = jwtTokenProvider.generateToken(user)
        return LoginResponse(token, UserView.from(user))
    }

    fun register(registerRequest: RegisterRequest): UserView {
        if (accountRepository.existsByUsername(registerRequest.username)) {
            throw BusinessException("用户名已存在")
        }

        val user = Account {
            username = registerRequest.username
            password = passwordEncoder.encode(registerRequest.password)
            email = registerRequest.email
            phone = registerRequest.phone
            status = UserStatus.ACTIVE
        }

        val savedUser = accountRepository.save(user)
        return UserView.from(savedUser)
    }
}
```

#### JwtTokenProvider

JWT Token 的生成和验证：

```kotlin
@Component
class JwtTokenProvider(
    @Value("\${jwt.secret}") private val secret: String,
    @Value("\${jwt.expiration}") private val expiration: Long
) {

    fun generateToken(user: Account): String {
        val claims = Jwts.claims().setSubject(user.username)
        claims["userId"] = user.id
        claims["roles"] = user.roles.map { it.name }

        return Jwts.builder()
            .setClaims(claims)
            .setIssuedAt(Date())
            .setExpiration(Date(System.currentTimeMillis() + expiration))
            .signWith(SignatureAlgorithm.HS512, secret)
            .compact()
    }

    fun validateToken(token: String): Boolean {
        return try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token)
            true
        } catch (e: Exception) {
            false
        }
    }
}
```

#### JwtAuthenticationFilter

JWT 认证过滤器：

```kotlin
@Component
class JwtAuthenticationFilter(
    private val jwtTokenProvider: JwtTokenProvider,
    private val userDetailsService: AccountUserDetailsService
) : OncePerRequestFilter() {

    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val token = getTokenFromRequest(request)

        if (token != null && jwtTokenProvider.validateToken(token)) {
            val username = jwtTokenProvider.getUsernameFromToken(token)
            val userDetails = userDetailsService.loadUserByUsername(username)

            val authentication = UsernamePasswordAuthenticationToken(
                userDetails, null, userDetails.authorities
            )
            SecurityContextHolder.getContext().authentication = authentication
        }

        filterChain.doFilter(request, response)
    }
}
```

### 安全配置

Spring Security 配置类：

```kotlin
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
class JwtSecurityConfig(
    private val jwtAuthenticationFilter: JwtAuthenticationFilter,
    private val jwtAuthenticationEntryPoint: JwtAuthenticationEntryPoint
) {

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        return http
            .csrf { it.disable() }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests {
                it.requestMatchers("/api/auth/**").permitAll()
                 .requestMatchers("/openapi/**", "/ts.zip").permitAll()
                 .anyRequest().authenticated()
            }
            .exceptionHandling { it.authenticationEntryPoint(jwtAuthenticationEntryPoint) }
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)
            .build()
    }
}
```

## 笔记服务架构

### 服务层次结构

笔记服务采用经典的分层架构：

```mermaid
graph TB
    Controller[笔记控制器] --> Service[笔记服务]
    Service --> Repository[笔记仓储]
    Repository --> KSqlClient[Jimmer SQL客户端]
    KSqlClient --> Database[(数据库)]

    Service --> AuthComponent[认证组件]
    Service --> TenantComponent[租户组件]
    Service --> LogComponent[日志组件]
```

### 核心实现

#### NoteService

笔记服务的业务逻辑实现：

```kotlin
@RestController
@RequestMapping("/api/notes")
@Transactional
class NoteService(
    private val noteRepository: NoteRepository,
    private val accountRepository: AccountRepository,
    private val logService: LogService
) {

    @GetMapping
    fun getNotes(
        @RequestParam(defaultValue = "0") page: Int,
        @RequestParam(defaultValue = "20") size: Int,
        @RequestParam(required = false) search: String?
    ): Page<NoteView> {
        val currentUser = getCurrentUser()

        val query = sqlClient.createQuery(Note) {
            where(table.author.id eq currentUser.id)
            search?.let {
                where(table.title ilike "%$it%" or table.content ilike "%$it%")
            }
            orderBy(table.createdTime.desc())
            select(table.fetch(NoteView::class))
        }

        return query.fetchPage(page, size)
    }

    @PostMapping
    @LogOperation("创建笔记")
    fun createNote(@Valid @RequestBody request: CreateNoteRequest): NoteView {
        val currentUser = getCurrentUser()

        val note = Note {
            title = request.title
            content = request.content
            author = currentUser
        }

        val savedNote = noteRepository.save(note)
        return NoteView.from(savedNote)
    }

    @PutMapping("/{id}")
    @LogOperation("更新笔记")
    fun updateNote(
        @PathVariable id: Long,
        @Valid @RequestBody request: UpdateNoteRequest
    ): NoteView {
        val currentUser = getCurrentUser()

        val note = noteRepository.findById(id)
            ?: throw EntityNotFoundException("笔记不存在")

        if (note.author.id != currentUser.id) {
            throw AccessDeniedException("无权限修改此笔记")
        }

        val updatedNote = noteRepository.save(note.apply {
            title = request.title
            content = request.content
        })

        return NoteView.from(updatedNote)
    }
}
```

#### NoteRepository

笔记数据访问层：

```kotlin
@Repository
class NoteRepository(sql: KSqlClient) : AbstractKotlinRepository<Note, Long>(sql) {

    fun findByAuthorId(authorId: Long): List<Note> {
        return sqlClient.createQuery(Note) {
            where(table.author.id eq authorId)
            orderBy(table.createdTime.desc())
            select(table)
        }.execute()
    }

    fun searchNotes(authorId: Long, keyword: String): List<Note> {
        return sqlClient.createQuery(Note) {
            where(
                table.author.id eq authorId,
                table.title ilike "%$keyword%" or table.content ilike "%$keyword%"
            )
            orderBy(table.createdTime.desc())
            select(table)
        }.execute()
    }
}
```

## 日志服务架构

### 日志记录机制

日志服务采用 AOP（面向切面编程）实现自动化的操作日志记录：

```mermaid
graph TB
    Controller[控制器方法] --> AOP[LogAspect切面]
    AOP --> LogService[日志服务]
    LogService --> LogRepository[日志仓储]
    LogRepository --> Database[(日志表)]

    AOP --> Context[安全上下文]
    AOP --> Request[HTTP请求]
```

### 核心组件

#### LogOperation 注解

```kotlin
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class LogOperation(
    val action: String,
    val description: String = ""
)
```

#### LogAspect 切面实现

```kotlin
@Aspect
@Component
class LogService(
    private val logRepository: LogRepository
) {

    @Around("@annotation(logOperation)")
    @LogOperation("API调用")
    fun logAround(
        joinPoint: ProceedingJoinPoint,
        logOperation: LogOperation
    ): Any? {
        val startTime = System.currentTimeMillis()

        try {
            val result = joinPoint.proceed()
            val endTime = System.currentTimeMillis()
            val duration = endTime - startTime

            // 记录成功日志
            recordLog(joinPoint, logOperation, "SUCCESS", duration, null)
            return result

        } catch (exception: Exception) {
            val endTime = System.currentTimeMillis()
            val duration = endTime - startTime

            // 记录失败日志
            recordLog(joinPoint, logOperation, "FAILED", duration, exception.message)
            throw exception
        }
    }

    private fun recordLog(
        joinPoint: ProceedingJoinPoint,
        logOperation: LogOperation,
        status: String,
        duration: Long,
        errorMessage: String?
    ) {
        val request = getCurrentRequest()
        val currentUser = getCurrentUser()

        val log = Log {
            user = currentUser
            action = logOperation.action
            method = joinPoint.signature.name
            path = request?.requestURI
            statusCode = if (status == "SUCCESS") 200 else 500
            ipAddress = getClientIpAddress(request)
            userAgent = request?.getHeader("User-Agent")
            requestTime = LocalDateTime.now()
            duration = duration
            errorMessage = errorMessage
        }

        logRepository.save(log)
    }
}
```

## 文件存储服务架构

### OSS 集成架构

文件存储服务基于阿里云 OSS 实现，支持文件上传、下载和管理：

```mermaid
graph TB
    Client[客户端] --> FileController[文件控制器]
    FileController --> OssService[OSS服务]
    OssService --> OSSClient[阿里云OSS客户端]
    OSSClient --> AliyunOSS[阿里云OSS服务]

    FileController --> FileRepository[文件仓储]
    FileRepository --> Database[(文件元数据表)]
```

### 核心实现

#### OssService

```kotlin
@Service
class OssService(
    private val ossClient: OSS,
    @Value("\${aliyun.oss.bucket-name}") private val bucketName: String,
    @Value("\${aliyun.oss.endpoint}") private val endpoint: String
) {

    fun uploadFile(file: MultipartFile, fileName: String): String {
        val objectName = generateUniqueFileName(fileName)

        val putObjectRequest = PutObjectRequest(bucketName, objectName, file.inputStream)
        putObjectRequest.metadata = ObjectMetadata().apply {
            contentLength = file.size
            contentType = file.contentType
        }

        ossClient.putObject(putObjectRequest)
        return "https://$bucketName.$endpoint/$objectName"
    }

    fun deleteFile(fileUrl: String): Boolean {
        val objectName = extractObjectNameFromUrl(fileUrl)
        return try {
            ossClient.deleteObject(bucketName, objectName)
            true
        } catch (e: Exception) {
            false
        }
    }

    private fun generateUniqueFileName(originalFileName: String): String {
        val timestamp = System.currentTimeMillis()
        val uuid = UUID.randomUUID().toString().replace("-", "")
        val extension = originalFileName.substringAfterLast(".", "")
        return "$timestamp-$uuid.$extension"
    }
}
```

#### FileController

```kotlin
@RestController
@RequestMapping("/api/files")
@Transactional
class FileService(
    private val staticFileRepository: StaticFileRepository,
    private val ossService: OssService
) {

    @PostMapping("/upload")
    @LogOperation("上传文件")
    fun uploadFile(
        @RequestParam("file") file: MultipartFile
    ): StaticFileView {
        val currentUser = getCurrentUser()

        // 上传到 OSS
        val fileUrl = ossService.uploadFile(file, file.originalFilename ?: "unknown")

        // 保存文件元数据
        val staticFile = StaticFile {
            fileName = extractFileName(fileUrl)
            originalName = file.originalFilename ?: "unknown"
            fileSize = file.size
            fileType = FileType.fromMimeType(file.contentType)
            fileUrl = fileUrl
            uploadedBy = currentUser
        }

        val savedFile = staticFileRepository.save(staticFile)
        return StaticFileView.from(savedFile)
    }

    @DeleteMapping("/{id}")
    @LogOperation("删除文件")
    fun deleteFile(@PathVariable id: Long) {
        val currentUser = getCurrentUser()

        val file = staticFileRepository.findById(id)
            ?: throw EntityNotFoundException("文件不存在")

        if (file.uploadedBy.id != currentUser.id) {
            throw AccessDeniedException("无权限删除此文件")
        }

        // 从 OSS 删除文件
        ossService.deleteFile(file.fileUrl)

        // 删除数据库记录
        staticFileRepository.delete(file)
    }
}
```

## 台账服务架构

### 台账系统架构

台账服务支持动态模板和记录管理：

```mermaid
graph TB
    Controller[台账控制器] --> TemplateService[模板服务]
    Controller --> RecordService[记录服务]

    TemplateService --> TemplateRepository[模板仓储]
    RecordService --> RecordRepository[记录仓储]

    TemplateRepository --> TemplateTable[(模板表)]
    RecordRepository --> RecordTable[(记录表)]
    RecordRepository --> ValueTable[(记录值表)]

    TemplateService --> ValidationService[验证服务]
    RecordService --> ValidationService
```

### 核心实现

#### LedgerTemplateService

```kotlin
@Service
@Transactional
class LedgerTemplateService(
    private val templateRepository: LedgerTemplateRepository,
    private val fieldRepository: LedgerTemplateFieldRepository
) {

    fun createTemplate(request: CreateTemplateRequest): LedgerTemplateView {
        val currentUser = getCurrentUser()

        val template = LedgerTemplate {
            name = request.name
            description = request.description
        }

        val savedTemplate = templateRepository.save(template)

        // 创建字段
        request.fields.forEach { fieldRequest ->
            val field = LedgerTemplateField {
                template = savedTemplate
                name = fieldRequest.name
                fieldType = fieldRequest.fieldType
                required = fieldRequest.required
                defaultValue = fieldRequest.defaultValue
            }
            fieldRepository.save(field)
        }

        return LedgerTemplateView.from(savedTemplate)
    }

    fun getTemplate(id: Long): LedgerTemplateView {
        val template = templateRepository.findById(id)
            ?: throw EntityNotFoundException("模板不存在")

        return LedgerTemplateView.from(template)
    }
}
```

#### LedgerRecordService

```kotlin
@Service
@Transactional
class LedgerRecordService(
    private val recordRepository: LedgerRecordRepository,
    private val valueRepository: LedgerRecordValueRepository,
    private val templateRepository: LedgerTemplateRepository
) {

    fun createRecord(request: CreateRecordRequest): LedgerRecordView {
        val currentUser = getCurrentUser()
        val template = templateRepository.findById(request.templateId)
            ?: throw EntityNotFoundException("模板不存在")

        // 验证字段值
        validateFieldValues(template, request.values)

        val record = LedgerRecord {
            this.template = template
            createdBy = currentUser
        }

        val savedRecord = recordRepository.save(record)

        // 保存字段值
        request.values.forEach { valueRequest ->
            val value = LedgerRecordValue {
                record = savedRecord
                field = template.fields.find { it.id == valueRequest.fieldId }
                    ?: throw IllegalArgumentException("字段不存在")
                value = valueRequest.value
            }
            valueRepository.save(value)
        }

        return LedgerRecordView.from(savedRecord)
    }

    private fun validateFieldValues(template: LedgerTemplate, values: List<CreateValueRequest>) {
        template.fields.forEach { field ->
            val value = values.find { it.fieldId == field.id }

            if (field.required && (value == null || value.value.isNullOrBlank())) {
                throw IllegalArgumentException("字段 ${field.name} 是必填项")
            }

            // 类型验证
            value?.let {
                validateFieldType(field.fieldType, it.value)
            }
        }
    }

    private fun validateFieldType(fieldType: FieldType, value: String) {
        when (fieldType) {
            FieldType.DECIMAL -> {
                value.toDoubleOrNull()
                    ?: throw IllegalArgumentException("无效的数字格式")
            }
            FieldType.DATE -> {
                LocalDate.parse(value)
                    ?: throw IllegalArgumentException("无效的日期格式")
            }
            FieldType.INTEGER -> {
                value.toIntOrNull()
                    ?: throw IllegalArgumentException("无效的整数格式")
            }
            else -> {
                // 字符串类型无需验证
            }
        }
    }
}
```

## 服务间交互

### 依赖关系

各个服务模块之间存在清晰的依赖关系：

```mermaid
graph TB
    Auth[认证服务] --> Note[笔记服务]
    Auth --> File[文件服务]
    Auth --> Ledger[台账服务]

    Log[日志服务] --> Auth
    Log --> Note
    Log --> File
    Log --> Ledger

    Tenant[租户服务] --> Note
    Tenant --> File
    Tenant --> Ledger
```

### 事务管理

服务层采用声明式事务管理：

```kotlin
@Service
@Transactional  // 类级别事务
class NoteService {

    @Transactional(readOnly = true)  // 只读事务
    fun getNote(id: Long): NoteView {
        // 查询操作
    }

    @Transactional  // 读写事务
    fun createNote(request: CreateNoteRequest): NoteView {
        // 创建操作
    }
}
```

### 异常处理

统一异常处理机制：

```kotlin
@RestControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(EntityNotFoundException::class)
    fun handleNotFound(exception: EntityNotFoundException): ResponseEntity<ErrorResponse> {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(ErrorResponse("NOT_FOUND", exception.message ?: "资源不存在"))
    }

    @ExceptionHandler(AccessDeniedException::class)
    fun handleAccessDenied(exception: AccessDeniedException): ResponseEntity<ErrorResponse> {
        return ResponseEntity
            .status(HttpStatus.FORBIDDEN)
            .body(ErrorResponse("ACCESS_DENIED", exception.message ?: "访问被拒绝"))
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(exception: Exception): ResponseEntity<ErrorResponse> {
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse("INTERNAL_ERROR", "服务器内部错误"))
    }
}
```

通过以上架构设计，ainote-server 实现了模块化、可扩展、高内聚低耦合的服务架构，为后续的功能扩展和系统维护提供了良好的基础。