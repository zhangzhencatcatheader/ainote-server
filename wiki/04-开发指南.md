# 开发指南

## 简介

本开发指南旨在为开发者提供在 `ainote-server` 项目基础上进行二次开发的详细指导。内容涵盖添加新实体、仓储和REST控制器的完整流程，强调构建时触发KSP代码生成的重要性，并介绍如何自定义拦截器、禁用多租户支持以及利用Jimmer框架的高级功能。同时提醒开发者清理示例代码以适配实际业务需求。

## 项目结构

本项目采用清晰的多模块架构，各模块职责分离，便于维护与扩展：

```
ainote-server/
├── model/          # 实体定义与公共基类
├── repository/     # 数据访问层（Spring Data风格仓储）
├── runtime/        # 运行时配置（过滤器、拦截器、解析器、缓存）
└── service/        # 服务层与REST控制器
```

模块间依赖关系如下：
- `service → repository → model`
- `service → runtime → model`
- `runtime → repository → model`

这种设计确保了数据模型的统一性，并支持灵活的服务组合与运行时行为定制。

## 添加新功能的完整流程

在本项目中添加新功能需遵循以下四步流程，确保类型安全与自动化机制正常工作。

### 第一步：在model模块定义新的实体接口

在 `model/src/main/kotlin/top/zztech/ainote/model/` 目录下创建新的Kotlin接口，继承 `BaseEntity`（若需多租户支持则同时继承 `TenantAware`）。

```kotlin
@Entity
interface YourEntity : BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long

    @Key
    val name: String
}
```

该实体将自动继承 `createdTime` 和 `modifiedTime` 审计字段，并由拦截器自动填充时间戳。

### 第二步：在repository模块创建对应的仓储类

在 `repository/src/main/kotlin/top/zztech/ainote/repository/` 目录下创建仓储类，继承 `AbstractKotlinRepository`，泛型参数为实体类型及其主键类型。

```kotlin
@Repository
class YourEntityRepository(sql: KSqlClient) : AbstractKotlinRepository<YourEntity, Long>(sql)
```

此仓储类将自动获得基本的增删改查能力，并可通过扩展函数添加自定义查询方法。

### 第三步：在service模块实现REST控制器

在 `service/src/main/kotlin/top/zztech/ainote/service/` 目录下创建服务类，使用 `@RestController` 和 `@RequestMapping` 注解暴露REST API。

```kotlin
@RestController
@RequestMapping("/your-entity")
@Transactional
class YourEntityService(
    private val yourEntityRepository: YourEntityRepository
) {
    // 实现具体业务逻辑
}
```

建议在此层处理事务管理、权限校验及业务编排。

### 第四步：运行 `./gradlew build` 触发KSP生成代码

**关键步骤**：每次添加或修改实体后，必须执行以下命令以触发Kotlin Symbol Processing (KSP) 生成必要的类型安全代码（如Draft类、查询DSL等）：

```bash
./gradlew build
```

若使用IDE开发，建议首次构建后再打开项目，或直接运行 `bootRun` 后所有生成类将自动出现。未执行构建将导致编译错误，因生成代码尚未存在。

## 自定义拦截器

Jimmer支持通过 `DraftInterceptor` 在保存实体前自动修改其属性。如需添加自定义逻辑（如自动填充创建人、状态初始化等），可在 `runtime/interceptor/` 目录下创建新的拦截器类。

示例结构如下：

```kotlin
@Component
class YourCustomDraftInterceptor : DraftInterceptor<YourEntity, YourEntityDraft> {
    override fun beforeSave(draft: YourEntityDraft, original: YourEntity?) {
        if (original == null) {
            draft.status = "ACTIVE"
        }
    }
}
```

此类将自动注册并应用于所有涉及 `YourEntity` 的保存操作。

## 禁用多租户功能

若项目无需多租户支持，可通过以下步骤完全禁用该功能：

1. **从实体中移除 `TenantAware` 接口**：修改所有实体，不再继承 `TenantAware`。
2. **删除租户相关拦截器**：移除 `TenantAwareDraftInterceptor.kt` 文件。
3. **删除租户过滤器**：移除 `TenantFilterForNonCacheMode.kt` 文件。
4. **清理配置文件中的安全定义**：在 `application.yml` 中删除 `securities` 和 `securitySchemes` 中关于 `tenantHeader` 的配置。

完成上述操作后，系统将不再强制检查 `tenant` 请求头，数据隔离逻辑也将失效。

## 使用Jimmer高级特性

Jimmer框架提供了多种高级功能，可显著提升开发效率与代码质量。

### DTO语言

在 `service/src/main/dto/` 目录下创建 `.dto` 文件，Jimmer将自动生成对应的Kotlin数据类。例如：

```
dto UserDto {
    String name
    String email
    List<Note> notes
}
```

执行构建后，将生成 `UserDto` 类，可用于API响应或请求体，实现前后端类型同步。

### 计算属性

支持在实体中定义 `@Formula` 或 `@Transient` 属性，用于表示数据库计算字段或运行时动态值。

```kotlin
@Formula("CONCAT(firstName, ' ', lastName)")
val fullName: String
```

此类属性在查询时会被自动计算，无需手动维护。

### Object Fetcher

Jimmer 的 Object Fetcher 允许查询任意形状的数据，避免 N+1 查询问题：

```kotlin
val users = sqlClient.createQuery(User) {
    select(table.fetch {
        name()
        orders {
            orderDate()
            items {
                productName()
                quantity()
            }
        }
    })
}.execute()
```

### Smart Save

Jimmer 的 Smart Save 功能可以保存任意形状的数据，自动检测 INSERT/UPDATE 操作：

```kotlin
sqlClient.save(userDraft)
```

## 测试

### 运行测试

```bash
./gradlew test
```

### 编写测试

测试文件应放在各模块的 `src/test/kotlin` 目录下。推荐使用：

- **JUnit 5**: 单元测试框架
- **MockK**: Kotlin 友好的 Mock 框架
- **Spring Boot Test**: 集成测试支持

示例测试类：

```kotlin
@SpringBootTest
@Transactional
class YourEntityServiceTest {

    @Autowired
    lateinit var yourEntityService: YourEntityService

    @Test
    fun `should create entity successfully`() {
        // 测试逻辑
    }
}
```

## 代码规范

### Kotlin 代码风格

- 使用官方 Kotlin 代码风格指南
- 优先使用不可变属性（`val` 而非 `var`）
- 充分利用 Kotlin 的空安全特性
- 使用扩展函数简化工具方法

### Jimmer 最佳实践

- 实体接口使用 `@Entity` 注解
- 主键使用 `@Id` 和 `@GeneratedValue`
- 唯一键使用 `@Key` 注解
- 关联关系使用正确的集合类型（`List`、`Set`）

## 清理项目模板

本项目包含示例实体（如 `Note`），在正式开发前建议删除以下文件以保持代码库整洁：

- `model/src/main/kotlin/top/zztech/ainote/model/Note.kt`
- `repository/src/main/kotlin/top/zztech/ainote/repository/NoteRepository.kt`
- `service/src/main/kotlin/top/zztech/ainote/service/NoteService.kt`

删除后重新运行 `./gradlew build` 以清理生成代码。

## 性能优化建议

### 数据库优化

- 合理使用 Jimmer 的 Object Fetcher 避免 N+1 查询
- 利用 Jimmer 的缓存机制减少数据库访问
- 适当设置数据库连接池参数

### 缓存策略

- 启用 Redis 缓存提升性能
- 配置合适的缓存过期时间
- 使用本地缓存减少 Redis 访问

### 代码优化

- 避免在循环中进行数据库操作
- 使用批量操作提升效率
- 合理使用事务边界

## 调试技巧

### 日志配置

在 `application.yml` 中配置日志级别：

```yaml
logging:
  level:
    top.zztech.ainote: DEBUG
    org.babyfish.jimmer: DEBUG
```

### SQL 调试

Jimmer 提供了 SQL 输出配置：

```yaml
jimmer:
  show-sql: true
  pretty-sql: true
```

### IDE 调试

- 使用 IntelliJ IDEA 的 Kotlin 调试器
- 设置断点查看 Jimmer 生成的 SQL
- 利用 IDE 的代码导航功能理解代码结构

通过遵循以上开发指南，您可以高效地在 ainote-server 项目基础上进行二次开发，充分利用 Jimmer ORM 的强大功能和 Kotlin 语言的现代化特性。